{"version":3,"sources":["webpack:///media-query.bundle.js","webpack:///webpack/bootstrap 5ed764b115dffba3a876","webpack:///./src/main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","MediaQuery","options","callback","context","arguments","undefined","this","query","_options$full","full","_matches","_mq","_callback","_context","_bound","_onMatch","bind","mq","matches","get","_query","set","val","constructor","remove","window","matchMedia","add","bound","addListener","removeListener","default"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,GAEtB,YAQA,SAASQ,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHC,OAAOC,eAAeb,EAAS,cAC7Bc,OAAO,GAGT,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMZ,OAAOC,eAAeI,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUX,EAAagB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBN,EAAYkB,UAAWF,GAAiBC,GAAaX,EAAiBN,EAAaiB,GAAqBjB,MEpB3hBmB,EFwDY,WEvDhB,QAAAA,GAAYC,EAAQC,GAAsB,GAAbC,GAAaC,UAAAb,OAAA,GAAAc,SAAAD,UAAA,GAAAA,UAAA,GAALE,IAAK3B,GAAA2B,KAAAN,EAAA,IACnCO,GAAoBN,EAApBM,MADmCC,EACfP,EAAdQ,OAD6BJ,SAAAG,IAExCF,MAAKI,UAAW,EAChBJ,KAAKG,KAAOA,EACZH,KAAKK,IAAM,KACXL,KAAKM,UAAYV,EACjBI,KAAKO,SAAWV,EAChBG,KAAKQ,OAASR,KAAKS,SAASC,KAAKV,MACjCA,KAAKC,MAAMA,EFiHZ,MA/CArB,GAAac,IACXJ,IAAK,WACLX,MAAO,SEjEDgC,GAEP,MADAX,MAAKI,SAAWO,EAAGC,QACZZ,KAAKM,UAAUrC,KAAK+B,KAAKO,SAASI,EAAGC,YFoE3CtB,IAAK,UACLuB,IAAK,WEjEN,MAAOb,MAAKI,YFqEXd,IAAK,QACLuB,IAAK,WElEN,MAAOb,MAAKc,QFqEXC,IAAK,SElEEC,GACRhB,KAAKc,OAASE,EACdhB,KAAKiB,YAAYC,OAAOlB,KAAKK,IAAIL,KAAKQ,OACtC,IAAIP,GAAQD,KAAKC,KACZA,KAGAD,KAAKG,MAAqB,MAAbF,EAAM,KACtBA,EAAQ,IAAMA,EAAQ,KAExBD,KAAKK,IAAMc,OAAOC,WAAWnB,GAC7BD,KAAKS,SAAST,KAAKK,KACnBL,KAAKiB,YAAYI,IAAIrB,KAAKK,IAAIL,KAAKQ,cFqElClB,IAAK,MACLX,MAAO,SEnECgC,EAAGW,GACRX,GACFA,EAAGY,YAAYD,MFuEhBhC,IAAK,SACLX,MAAO,SEpEIgC,EAAGW,GACXX,GACFA,EAAGa,eAAeF,GAEpBX,EAAK,SFwECjB,IAGT7B,GAAQ4D,QExEM/B,EFyEd5B,EAAOD,QAAUA,EAAiB","file":"media-query.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Created by IvanP on 13.12.2016.\n\t */\n\t/**\n\t * `MediaQuery` helps perform actions when CSS query is matched instead of polling the window width, when it's not so important to get exact width, only checking matching the query.\n\t *\n\t * ``` javascript\n\t * function onMatch(matches){\n\t *  if(matches){\n\t *    // do what you need when the mediaquery is matched\n\t *  } else {\n\t *     // do what you need when the media query is not matched\n\t *  }\n\t * }\n\t *\n\t *  var mq = new MediaQuery({query:\"max-width:760px\"},onMatch,this);\n\t *\n\t *  //at any time you may check whether it matches the query:\n\t *\n\t *  mq.matches //true or false\n\t * ```\n\t *\n\t * @param {Object} options\n\t * @param {Object} options.query - The CSS media query to evaluate.\n\t * @param {Boolean} [options.full=false] - If true, the query attribute is assumed to be a complete media query string rather than a single media feature.\n\t * @param {Function} callback - function to execute when matching is evaluated\n\t * @param {Object|Function} [context=this] - context in which the `callback` function needs to be executed\n\t *\n\t * @property {Boolean} matches - whether the query matches the window width. Readonly.\n\t * @property {Boolean} full - If true, the query attribute is assumed to be a complete media query string rather than a single media feature.\n\t * @property {String} query - The CSS media query to evaluate.\n\t * */\n\tvar MediaQuery = function () {\n\t  function MediaQuery(options, callback) {\n\t    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;\n\t\n\t    _classCallCheck(this, MediaQuery);\n\t\n\t    var query = options.query,\n\t        _options$full = options.full,\n\t        full = _options$full === undefined ? false : _options$full;\n\t\n\t    this._matches = false;\n\t    this.full = full;\n\t    this._mq = null;\n\t    this._callback = callback;\n\t    this._context = context;\n\t    this._bound = this._onMatch.bind(this);\n\t    this.query = query;\n\t  }\n\t\n\t  _createClass(MediaQuery, [{\n\t    key: '_onMatch',\n\t    value: function _onMatch(mq) {\n\t      this._matches = mq.matches;\n\t      return this._callback.call(this._context, mq.matches);\n\t    }\n\t  }, {\n\t    key: 'matches',\n\t    get: function get() {\n\t      return this._matches;\n\t    }\n\t  }, {\n\t    key: 'query',\n\t    get: function get() {\n\t      return this._query;\n\t    },\n\t    set: function set(val) {\n\t      this._query = val;\n\t      this.constructor.remove(this._mq, this._bound);\n\t      var query = this.query;\n\t      if (!query) {\n\t        return;\n\t      }\n\t      if (!this.full && query[0] !== '(') {\n\t        query = '(' + query + ')';\n\t      }\n\t      this._mq = window.matchMedia(query);\n\t      this._onMatch(this._mq);\n\t      this.constructor.add(this._mq, this._bound);\n\t    }\n\t  }], [{\n\t    key: 'add',\n\t    value: function add(mq, bound) {\n\t      if (mq) {\n\t        mq.addListener(bound);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(mq, bound) {\n\t      if (mq) {\n\t        mq.removeListener(bound);\n\t      }\n\t      mq = null;\n\t    }\n\t  }]);\n\t\n\t  return MediaQuery;\n\t}();\n\t\n\texports.default = MediaQuery;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// media-query.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5ed764b115dffba3a876","/**\n * Created by IvanP on 13.12.2016.\n */\n/**\n * `MediaQuery` helps perform actions when CSS query is matched instead of polling the window width, when it's not so important to get exact width, only checking matching the query.\n *\n * ``` javascript\n * function onMatch(matches){\n *  if(matches){\n *    // do what you need when the mediaquery is matched\n *  } else {\n *     // do what you need when the media query is not matched\n *  }\n * }\n *\n *  var mq = new MediaQuery({query:\"max-width:760px\"},onMatch,this);\n *\n *  //at any time you may check whether it matches the query:\n *\n *  mq.matches //true or false\n * ```\n *\n * @param {Object} options\n * @param {Object} options.query - The CSS media query to evaluate.\n * @param {Boolean} [options.full=false] - If true, the query attribute is assumed to be a complete media query string rather than a single media feature.\n * @param {Function} callback - function to execute when matching is evaluated\n * @param {Object|Function} [context=this] - context in which the `callback` function needs to be executed\n *\n * @property {Boolean} matches - whether the query matches the window width. Readonly.\n * @property {Boolean} full - If true, the query attribute is assumed to be a complete media query string rather than a single media feature.\n * @property {String} query - The CSS media query to evaluate.\n * */\nclass MediaQuery{\n  constructor(options,callback,context=this){\n    let {query,full=false} = options;\n    this._matches = false;\n    this.full = full;\n    this._mq = null;\n    this._callback = callback;\n    this._context = context;\n    this._bound = this._onMatch.bind(this);\n    this.query=query;\n  }\n\n  _onMatch(mq){\n    this._matches = mq.matches;\n    return this._callback.call(this._context,mq.matches)\n  }\n\n  get matches(){\n    return this._matches;\n  }\n\n  get query(){\n    return this._query;\n  }\n\n  set query(val){\n    this._query = val;\n    this.constructor.remove(this._mq,this._bound);\n    let query = this.query;\n    if (!query) {\n      return;\n    }\n    if (!this.full && query[0] !== '(') {\n      query = '(' + query + ')';\n    }\n    this._mq = window.matchMedia(query);\n    this._onMatch(this._mq);\n    this.constructor.add(this._mq,this._bound);\n  }\n\n  static add(mq,bound){\n    if (mq) {\n      mq.addListener(bound);\n    }\n  }\n\n  static remove(mq,bound) {\n    if (mq) {\n      mq.removeListener(bound);\n    }\n    mq = null;\n  }\n}\nexport default MediaQuery\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}